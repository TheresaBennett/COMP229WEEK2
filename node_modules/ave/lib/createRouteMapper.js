'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodashIsequal = require('lodash.isequal');

var _lodashIsequal2 = _interopRequireDefault(_lodashIsequal);

var _uniloc = require('uniloc');

var _uniloc2 = _interopRequireDefault(_uniloc);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _urlMapperMapper = require('url-mapper/mapper');

var _urlMapperMapper2 = _interopRequireDefault(_urlMapperMapper);

var _util = require('util');

function createRouteMapper(routeDefinitions) {
  var routePathMap = {};
  var routeObjectMap = {};
  var mapper = (0, _urlMapperMapper2['default'])(createRouteCompiler);
  var followRedirects = protectFromInfiniteRecursion(_followRedirects);
  var formatRoute = protectFromInfiniteRecursion(_formatRoute);
  Object.keys(routeDefinitions).forEach(function (routeName) {
    var routeDefinition = Object.freeze(_extends({}, routeDefinitions[routeName], {
      name: routeName
    }));
    routePathMap[routeDefinition.route] = routeDefinition;
    routeObjectMap[routeDefinition.name] = routeDefinition;
    var aliases = routeDefinition.aliases || [];
    aliases.forEach(function (alias) {
      routePathMap[alias] = routeDefinition;
    });
  });
  return {
    // Looks up a route by path name.
    //
    // - `path` A String representing the pathname. e.g. `/projects/1`
    //
    // Returns an Object with these keys:
    //
    // - `name` A String representing the route name.
    // - `options` An Object containing the route parameters and other.
    //
    resolve: function resolve(path) {
      var result = mapper.map(path, routePathMap);
      if (!result) return null;
      return validateAndCoerceRoute({ name: result.match.name, options: result.values });
    },

    // Ensures that a route is valid, and also follows all the redirects.
    //
    route: function route(routeObject) {
      return validateAndCoerceRoute(routeObject);
    },

    // Generates a path from the specified `name` and `options`.
    //
    // Returns a String.
    //
    generate: function generate(unvalidatedRouteObject) {
      var validatedRoute = validateAndCoerceRoute(unvalidatedRouteObject);
      var formattedRoute = formatRoute(validatedRoute);
      if (process.env.NODE_ENV !== 'production') {
        var resolvedRoute = validateAndCoerceRoute(formattedRoute);
        (0, _invariant2['default'])((0, _lodashIsequal2['default'])(validatedRoute, resolvedRoute), 'The formatted route for ' + (0, _util.inspect)(validatedRoute) + ', which is ' + (0, _util.inspect)(formattedRoute) + ' did not resolve back to the same route. Instead, it resolved to ' + (0, _util.inspect)(resolvedRoute));
      }
      var template = routeObjectMap[formattedRoute.name].route;
      return mapper.stringify(template, formattedRoute.options).replace(/\?.+/, function (a) {
        return a.replace(/%2f/ig, '/');
      });
    },

    // Returns the route definition object identified by `name`.
    //
    // Returns a route definition object.
    //
    getRouteDefinitionByName: function getRouteDefinitionByName(name) {
      return routeObjectMap[name];
    }
  };

  function validateAndCoerceRoute(route) {
    (0, _invariant2['default'])(typeof route.name === 'string', 'route.name must be a string');
    (0, _invariant2['default'])(route.options, 'route.options must be present');
    (0, _invariant2['default'])(typeof route.options === 'object', 'route.options must be an object');
    return followRedirects(route);
  }

  function _followRedirects(route) {
    var routeDefinition = routeObjectMap[route.name];
    (0, _invariant2['default'])(routeDefinition, 'Unrecognized route: ' + route.name);
    if (typeof routeDefinition.redirect === 'function') {
      return followRedirects(routeDefinition.redirect(route.options));
    }
    return route;
  }

  function _formatRoute(route) {
    var routeDefinition = routeObjectMap[route.name];
    (0, _invariant2['default'])(routeDefinition, 'Unrecognized route: ' + route.name);
    if (typeof routeDefinition.format === 'function') {
      var formattedRoute = routeDefinition.format(route.options);
      if (!formattedRoute) return route;
      if (!(0, _lodashIsequal2['default'])(route, formattedRoute)) return formatRoute(formattedRoute);
    }
    return route;
  }
}

var protectFromInfiniteRecursion = (function () {
  var _stack = [];
  return function (f) {
    return function () {
      try {
        if (_stack.length > 10) {
          throw new Error('Recursive limit reached! Hereâ€™s the most recent stack: ' + (0, _util.inspect)(_stack));
        }
        _stack.push(arguments[0]);
        return f.apply(this, arguments);
      } finally {
        _stack.pop();
      }
    };
  };
})();

// HACK: Using uniloc only to generate mapper for only a single route for now
//       until these are fixed:
//         - https://github.com/unicorn-standard/uniloc/issues/4
//         - https://github.com/unicorn-standard/uniloc/issues/5
//
function createRouteCompiler(path) {
  var router = (0, _uniloc2['default'])({ route: 'GET ' + path });
  return {
    parse: function parse(url) {
      var result = router.lookup(url);
      if (!result || !result.name) return null;
      return result.options || {};
    },
    stringify: function stringify(values) {
      return router.generate('route', values);
    }
  };
}

exports['default'] = createRouteMapper;
module.exports = exports['default'];